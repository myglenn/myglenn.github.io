## 컴퓨터는 어떻게 작동할까?
우리는 매일 컴퓨터로 프로그램을 실행해 무언가를 작업합니다. IDE를 켜서 업무를 하고, 게임을 즐기고, 다양한 작업을 하죠. 너무나 당연하게 사용하는 컴퓨터지만, 어느 날 문득 이런 생각이 들었습니다.   
> "이론으로 배웠지만 이해가 안 가, 그래서 진짜 컴퓨터는 어떻게 작동하는거지?"   

이 궁금증을 풀기 위해 하나의 프로그램이 실행되는 과정을 처음부터 끝까지 따라가 보려 합니다.

## 아주 옛날의 컴퓨터
지금처럼 컴퓨터가 프로그램을 실행하고, 다양한 일을 처리하게 되기 전, 초기의 계산기기들은 오직 정해진 연산만 수행할 수 있는 기계 였습니다.
* 톱니바퀴를 돌려 계산하던 기계식 계산기  
* 전선을 다시 연결해서 동작을 바꾸는 컴퓨터(ENIAC)   

이 시기의 기계들은 계산은 가능하지만, 유연한 실행은 불가능한 구조였죠.

## 폰 노이만 구조의 등장
1945년, 수학자 폰 노이만은 한 가지 혁명적인 아이디어를 제안합니다.   
> 명령어도 데이터처럼 메모리에 저장해서,   
> CPU가 순서대로 꺼내서 해석하고 실행하도록 하자.

이 아이디어는 오늘날 우리가 사용하는 모든 컴퓨터 구조의 출발점이 되었고, 이를 가리며 우리는 그것을 폰 노이만 구조라고 명명하였습니다.

## 모든 건 파일에서 시작
우리가 흔히 생각하는 윈도우 os의 환경과, 김치볶음밥을 예로 들어서 설명해보겠습니다.   
모든 프로그램은 실행되기 전까지는 단순한 하나의 파일일 뿐입니다. 즉 김치볶음밥으로 비유하자면, 레시피가 책에 적혀 있는 상태지, 아직 프라이팬에 불이 붙은 건 아니죠.   
우리가 아이콘을 더블클릭하는 순간, 운영체제가 이 파일을 RAM으로 적재하고, 프로세스를 생성하여, 드디어 김치볶음밥 요리가 시작됩니다.

## 프로그램이 실행된다는 건
우리가 김치볶음밥 레시피를 꺼내어 실제로 요리를 시작하려면 재료를 꺼내고, 도구를 준비하고, 작업 순서도 정해야 합니다. 
컴퓨터도 마찬가지 입니다. 단순히 파일을 실행한다고 해서 곧바로 요리가 되는건 아니니까요.

## 프로그램 실행 준비
사용자가 프로그램을 실행하면 OS는 해당 실행 파일을 디스크에서 꺼내 RAM 영역에 적재합니다. RAM은 단순한 창고가 아니라, 조리대이자 조리도구, 레시피 보관함 같은 공간입니다. 모든 실행 흐름이 이곳에서 시작되죠.
RAM 자체는 연속된 메모리 공간이지만, 운영체제는 프로그램이 실행되도록 논리적인 구역으로 나누어 관리합니다.   
RAM 내 주소 순서를 그림으로 보면 다음과 같습니다.   

```
[ 낮은 주소 ]
┌─────────────────────────┐
│ 코드 영역 (.text)             ← 스레드가 실행할 명령어들이 저장됨(레시피 북)
├─────────────────────────┤
│ 데이터 영역 (.data/.bss)      ← 프로그램 전체에서 공유되는 전역 변수, 정적 변수가 저장됨(항상 쓰이는 재료)
├─────────────────────────┤
│ 힙 (Heap)                    ← 동적 메모리(new, malloc 등)(요리 도중 추가로 꺼내오는 재료)
│      ↑ 증가
├─────────────────────────┤
│      ↓ 감소
│ 스택 (Stack)                  ← 함수 호출, 지역 변수, 함수 실행 흐름이 저장됨 (요리 흐름 등) -> LIFO
└─────────────────────────┘
[ 높은 주소 ]
```   

* 코드 영역: 레시피처럼, 실행할 기계어, 명령어들이 저장됩니다.   
* 데이터 영역: 미리 준비된 재료(전역 변수, 상수 등)가 보관됩니다.   
* 힙: 요리 도중 새로 꺼낸 재료처럼, 동적으로 할당된 데이터들이 저장됩니다.   
* 스택: 요리 순서와 중간 상태를 쌓아올리는 공간입니다.   

## 여기서 잠깐! 프로세스 생성?
방금 말한 것처럼, 실행 파일이 RAM에 올라왔다고 해서 곧바로 프로그램이 실행되는 건 아닙니다.
> 이 시점에서 운영체제는 하나의 프로세스(Process)를 생성합니다.   

프로세스는 하나의 독립된 실행 단위로,  
* 고유한 ID (PID)   
* RAM 내의 독립된 메모리 공간   
* 명령어 실행 흐름   
* 스택/힙 영역 등을 포함합니다.   

다시 김치볶음밥 비유로 돌아가면, 
> “오늘 김치볶음밥 만들 거예요!” 라고 선언한 순간,   
> OS가 RAM 공간에 나만의 요리대를 세팅해주는 것과 같습니다.

이제 이제 그 명령어를 실행할 요리사, CPU가 등장할 차례입니다.

## CPU는 요리사
RAM에 실행 파일이 적재되고 OS가 프로세스를 생성하고 스레드도 준비 되었습니다.   
이제 CPU가 나설 차례인데요, CPU는 말 그대로 중앙 처리 장치 즉 컴퓨터가 계산하고 명령을 수행하는 실제 실행자 입니다.   
하지만 사람처럼 CPU는 스스로 판단하거나 창의적으로 생각하지 않습니다. 생산 공장에 가깝다고 생각하면 적절할까요,   

> 오직 RAM에 올라와 있는 명령어만 보고   
> 그 명령어를 순서대로 해석하고 실행하는 일을 반복할 뿐입니다.   

이 명령어의 흐름은 스레드라는 단위로 구성되어 있고 CPU는 OS가 넘겨준 스레드의 명령어를 따라 실행 흐름을 수행합니다.   

## CPU의 명령어 사이클
CPU는 아래의 세 단계를 빠르게 반복하면서 프로그램을 실행합니다.   
1. Fetch    - 명령어를 RAM에서 가져온다.   
2. Decode   - 무슨 명령인지 해석한다.   
3. Execute  - 실제 계산이나 동작을 수행한다.   

이 과정을 매우 빠르게, 초당 수십억 번 반복하면서 우리가 말하는 "프로그램이 돌아간다"는 일이 실제로 일어납니다.   

1. Fetch    - 한 개의 요리 과정을 가져온다.
2. Decode   - 어떠한 작업을 해야하는지 읽는다.
3. Excute   - 읽어낸 작업을 실행한다. ( 예 : 김치를 도마 위에 올려놓는다.)   

이런 동작을 반복하면서 김치볶음밥이 점점 완성되듯 CPU도 명령어를 하나하나 차례로 처리하면서 프로그램을 실제로 실행합니다.

## 스레드가 실행되는 동안, 메모리는 어떻게 쓰일까?
앞서 설명했지만 다시 언급하자면, 스레드는 CPU가 따라가는 명령어 흐름이며, 그 명령어들은 모두 RAM의 코드 영역(.text)에 저장돼 있습니다.   
스레드가 실행되면서, 명령어를 수행하기 위해 RAM의 여러 영역을 다음과 같이 오가며 사용합니다.   

1. 코드 영역(.text):  
   스레드는 명령어를 순서대로 여기서 가져와 실행합니다. (예: “김치를 넣는다” → 레시피 줄 한 줄)   

2. 데이터 영역(.data/.bss):  
   전역 변수나 상수 같은 값은 여기서 읽거나 씁니다. (예: 항상 옆에 두는 참기름, 간장 같은 재료)   

3. 스택(Stack):  
   함수가 호출될 때마다 스택 프레임을 쌓고, 지역 변수와 실행 흐름(리턴 주소 등)을 이 안에 저장합니다. (예: 지금 무슨 단계까지 요리했는지 순서 기록)   

4. 힙(Heap):  
   실행 중에 새로운 메모리가 필요할 때, `new`, `malloc` 등으로 동적 메모리를 이곳에 할당합니다. (예: 요리 도중 갑자기 두부도 넣자 하고 새 재료 꺼내기)   


## 김치볶음밥으로 정리!
- 스레드는 레시피(코드)를 한 줄씩 따라가며   
- 고정 재료(데이터)를 꺼내 쓰고   
- 현재 진행 상황(스택)에 기록하며   
- 필요할 때 새로운 재료(힙)를 꺼내 추가합니다.   

이 모든 과정을 통해 프로그램은 단순한 파일에서 실제 동작하는 요리로 바뀌게 되는 것이죠.

## 프로그램이 종료되면 메모리는 어떻게 될까?
실행 중이던 프로그램이 종료되면 그 프로그램을 위해 OS가 할당했던 메모리 공간은 모두 해제됩니다.   
코드, 데이터, 스택, 힙에 존재하던 정보들은 더 이상 쓸 일이 없기 때문에 RAM에서 사라지게 됩니다. 디스크에 있는 원래의 실행 파일은 그대로 남아있고, RAM은 다시 다음 작업을 위한 준비 상태로 되돌아갑니다. 마치 요리를 끝낸 뒤 조리 공간을 깨끗이 정리하고 다음 요리를 기다리는 주방처럼 말입니다.

## 요약
* 프로그램을 실행하면 OS는 RAM에 적재하고 프로세스를 생성함
* RAM은 코드, 데이터, 스택, 힙 등의 논리적 공간이 나뉘어 프로그램 실행을 지원함
* 스레드는 CPU가 실제로 실행하는 명령어 흐름이며 명령어 사이클(Fetch / Decode / Execute)을 통해 코드 영역의 명령어를 해석하고 실행함
* 프로그램이 종료되면 OS는 RAM에 할당된 메모리를 지우고 컴퓨터는 다시 다음 실행을 위한 상태로 되돌아감

## 참고자료
- [Wikipedia – Von Neumann architecture](https://en.wikipedia.org/wiki/Von_Neumann_architecture)   
- [Wikipedia – Instruction_cycle](https://en.wikipedia.org/wiki/Instruction_cycle)   
- [geeksforgeeks – Program Execution in the CPU](https://www.geeksforgeeks.org/program-execution-in-the-cpu/)