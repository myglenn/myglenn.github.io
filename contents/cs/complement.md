## 효자 파스칼과 최초의 기계식 계산기
1642년, 프랑스의 수학자이자 효자인 블레즈 파스칼은  
아버지의 세금 계산을 도와주기 위해 세계 최초의 기계식 계산기를 만들었습니다.  
이 계산기는 톱니바퀴를 이용해 숫자판을 돌려 입력하고, 계산 결과를 자동으로 처리하는 방식으로 동작했으며, 오늘날 덧셈 계산기의 기원이라고 할 수 있습니다.    
> 예 : 어떤 자리의 숫자가 9에서 0으로 넘어가는 경우, 톱니바퀴가 옆 자리의 축을 한 칸 밀어 올려 자동으로 자리 올림(carry)이 발생하도록 설계되어 있었습니다.   
하지만 이 계산기는 덧셈만 가능한 구조였기 때문에 뺄셈 전용 메커니즘은 없었습니다.  
그래서 뺄셈은 ‘보수를 이용한 덧셈’ 방식으로 간접 처리했는데, 예를 들어 9 - 6을 계산할 때는 6의 10의 보수인 4를 더해 9 + 4 = 13을 만들고, 초과된 10을 버리면 최종적으로 3이 됩니다.  
이처럼 뺄셈이 필요한 상황에서 보수 개념은 반드시 필요했고, 이는 후에 컴퓨터 연산 방식의 기초가 되었습니다.

## 컴퓨터는 0과 1밖에 모르는 기계
우리가 사용하는 컴퓨터는 똑똑한 두뇌처럼 보이지만 사실은 전기가 흐르냐, 흐르지 않느냐만을 구분할 수 있는 단순한 스위치들의 집합입니다.
> 전류가 흐르면 true (1)
> 전류가 흐르지 않으면 false (0)   
이처럼 두 가지 상태만 구별할 수 있기 때문에 컴퓨터는 모든 데이터와 연산을 0과 1로 표현해야 합니다. 이 체계가 바로 우리가 말하는 이진법(binary)이고 이진법이 컴퓨터 과학의 가장 기초적인 언어가 된 이유입니다.

## 그래서, 컴퓨터는 왜 파스칼 계산기와 닮았을까?
앞서 말했듯이, 컴퓨터는 오직 0과 1만을 사용할 수 있기 때문에 우리가 일상에서 사용하는 음수(-3, -10 등)는 이진법으로 직접 표현할 수 없습니다. 또한, 뺄셈 연산을 위한 전용 회로를 만들기에는 구조가 복잡하고 비효율적이었죠.   
이런 이유로, 컴퓨터는 파스칼 계산기처럼 ‘덧셈만 할 수 있는 구조’를 선택했고 뺄셈은 보수를 이용한 덧셈으로 해결하게 되었습니다.   
컴퓨터는 음수를 2의 보수 방식으로 표현하고 덧셈 회로만으로 연산을 처리합니다. 이 방식 덕분에 뺄셈을 덧셈으로 바꾸어 구현할 수 있습니다.
> 예: A - B 라는 뺄셈은, 사실상 컴퓨터 내부에서는 A + (-B)로 처리됩니다. 그리고 -B는 B의 2의 보수로 표현됩니다.   
이때 중요한 점은, n-1 보수만으로는 정확한 결과가 나오지 않고, 반드시 +1을 더해서 n 보수를 사용해야 한다는 것입니다.   
n-1 보수는 각 자리 수를 반전시켜 만드는 '중간 단계'일 뿐이고, 실제 연산에선 n 보수(=n-1 보수 + 1)를 사용해야만 결과가 올바르게 나옵니다.
> 예 : 54 - 34를 계산할 때, 34의 9의 보수는 65이지만, 54 + 65 = 119로 정답보다 1이 부족합니다.   
이 문제는 +1을 더하지 않았기 때문인데, 정확한 보수인 66(10의 보수)을 사용하면 54 + 66 = 120이 되고, 자리올림된 100을 버리면 정확한 답인 20이 나옵니다.

## 보수는 무엇일까?
보수(Complement)란 어떤 수에 더하면 기준값(n)이 되는 숫자를를 의미합니다. 예를 들어 3의 10의 보수는 7입니다. 왜냐면 3 + 7 = 10이 되니까요.   
이 개념은 컴퓨터가 직접 뺄셈을 하지 못하기 때문에, 뺄셈을 덧셈으로 바꾸기 위한 도구로 사용됩니다. 즉, 컴퓨터는 덧셈만 처리할 수 있으므로, 우리가 보수를 이용해서 간접적으로 뺄셈을 하는 구조입니다.

## n-1의 보수? n의 보수?
n-1 보수와 n 보수의 차이를 이해하는 것은 보수 연산의 핵심입니다. 최대한 쉽게 설명하자면:
* n-1 보수(예 : 9의 보수, 1의 보수)는 뒤집기용 보조 수이고 각 자리 수를 최댓값(n-1)에서 빼는 방식으로 구합니다. 이 과정은 직관적으로 “자릿수를 뒤집는다” 또는 “거울처럼 반대값을 취한다”고 표현됩니다.
> 예: 3의 9의 보수는 → 9 - 3 = 6, 즉 3 + 6 = 9   
하지만 이 값은 정확한 계산을 하기 위해선 +1을 더해야 하므로, 최종 연산엔 n 보수를 사용합니다.
* n 보수(예 : 10의 보수, 2의 보수)는 실제 연산에 적용되며 n-1 보수에 1을 더하는 방식이며 실제 연산에 필요합니다.

## 왜 n-1의 보수는 계산에 바로 쓸 수 없을까?
A에서 B를 빼려면, 원래 계산식은 A - B입니다. 하지만 앞서 말했듯이 컴퓨터는 뺄셈을 직접 하지 못하므로 보수를 이용해서 덧셈으로 바꾸는 방법을 사용합니다.
> 예: 54-34 = 20 이걸 덧셈으로 바꾸려면 우리는 34의 10의 보수를 구해서 54에 더합니다.
여기서 기준값으로 100을 사용하는 이유는, 계산 대상인 숫자들이 두 자리 수이기 때문입니다. 그래서 가장 가까운 자리올림 단위인 100(=10^2)을 보수 기준값으로 사용하는 것이죠. 이처럼 보수 계산은 항상 '자릿수가 올라가는 기준값'을 중심으로 만들어지며, 컴퓨터에서도 이 개념은 비트 수(예: 2ⁿ)를 기준으로 확장됩니다.   
* 100 - 34 = 66 (34의 10의 보수)
* -> 54 + 66 = 120 이니까, 초과된 100을 버리면 20 -> 이렇게 정확한 결과가 나옵니다. 

## 계산 예제 1 - 10진수의 뺄셈
> 54 - 34
1. 34의 9의 보수 (n-1 보수): 99 - 34 = 65
2. 거기에 +1 해서 10의 보수 (n 보수): 66
3. 덧셈 수행: 54 + 66 = 120
4. 자리 올림(100)을 버리면 → 20 (정답!)
* 만약 65 (n-1 보수)만 더하면 → 54 + 65 = 119 → 19 (오답!)

## 계산 예제 2 - 2진수의 뺄셈
>  7 - 5 = ?
1. 7 → 00000111
2. 5 → 00000101 → 반전(1의 보수): 11111010 → +1 → 11111011 (2의 보수)
3. 덧셈: 00000111 + 11111011 = 00000010 (앞자리 캐리 버림)
4. 결과: 2
* 컴퓨터는 이 과정을 “덧셈만으로 뺄셈을 처리”하는 데 사용합니다. 이때 연산 결과가 표현 가능한 비트 수를 초과하면, 가장 왼쪽에 생기는 자리(캐리 비트)는 자동으로 버려집니다. 왜냐하면 컴퓨터는 정해진 비트 수(예: 8비트, 16비트 등)만을 사용해 계산하기 때문입니다.
* 이 초과 비트는 연산 범위를 벗어난 값으로 판단되어, 하드웨어 차원에서 무시되도록 설계되어 있습니다. 따라서 뺄셈 결과에서 이 캐리 비트를 제거함으로써 정확한 최종 값이 도출됩니다.

## 요약
* 보수는 덧셈으로 뺄셈을 구현하기 위한 인간의 아이디어임
* 컴퓨터는 음수나 뺄셈을 모름 → 대신 보수를 활용한 덧셈만 함
* n-1 보수는 단지 준비 과정일 뿐, 실제 계산엔 사용되지 않음
* 항상 n-1 보수에 +1 한 n 보수를 덧셈에 사용해야 정답이 나옴

## 참고자료  
* [Wikipedia – Pascaline](https://en.wikipedia.org/wiki/Pascaline) 
* [Wikipedia – Ten's complement](https://en.wikipedia.org/wiki/Method_of_complements)  
* [Wikipedia – Two's complement](https://en.wikipedia.org/wiki/Two%27s_complement)  